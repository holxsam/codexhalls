import { HeroSection } from "@/components/HeroSection/HeroSection";
import { getDictionary } from "@/utils/get-dictionary";
import { LParam } from "./layout";
import { genRandomTree, getRandomColorFromSet } from "@/utils/utils";
import { GEdge, GNode, GraphData } from "@/store/GraphStore";
import forceLayout from "ngraph.forcelayout";
import createGraph from "ngraph.graph";
import largeGraphData from "@/utils/large-graph-data.json";

const physicsSettings = {
  // timeStep: 0.5,
  dimensions: 3,
  // gravity: -12,
  // theta: 0.8,
  // springLength: 10,
  // springCoefficient: 0.8,
  // dragCoefficient: 0.9,
};

const fetchGraphDataWithSimulation = async (): Promise<GraphData> => {
  // large data to test for performance:
  // const graphData: GraphData = {
  //   nodes: largeGraphData.nodes.map((node) => ({
  //     ...node,
  //     val: 1,
  //     color: getRandomColorFromSet(),
  //     position: [0, 0, 0],
  //     scale: [2, 2, 2],
  //     rotation: [0, 0, 0],
  //   })),
  //   edges: largeGraphData.links.map((edge, i) => ({
  //     ...edge,
  //     id: `${i}`,
  //     color: getRandomColorFromSet(),
  //   })),
  // };

  // random data to test the force layout:
  const graphData = genRandomTree(200, 1);

  // random data to test the force layout:
  // const graphData = stableData;

  // create a graph and populate it with data:
  const g = createGraph<GNode, GEdge>();
  graphData.nodes.forEach((node) => g.addNode(node.id));
  graphData.edges.forEach((edge) => g.addLink(edge.source, edge.target));

  // use force simulation to generate positions of each node:
  const layout = forceLayout(g, physicsSettings);

  // must iterate the simulation to get a good layout:
  for (let i = 0; i < 500; i++) {
    if (layout.step()) break; // break out early if simulation is stable
  }

  // store the new positions of the nodes generated by the force layout
  graphData.nodes.forEach((node) => {
    const { x, y, z = 0 } = layout.getNodePosition(node.id);
    node.position = [x, y, z];
  });

  return graphData;
};

export default async function Home({ params }: { params: LParam }) {
  const t = await getDictionary(params.lang);
  const graphData = await fetchGraphDataWithSimulation();

  return (
    <div className="isolate flex flex-col gap-28 pb-32">
      <HeroSection dictionary={t} graphData={graphData} />
    </div>
  );
}

const stableData: GraphData = {
  nodes: [
    {
      id: "0",
      val: 1,
      color: "#f43f5e",
      position: [0, 0, 0],
      scale: [2, 2, 2],
      rotation: [0, 0, 0],
    },
    {
      id: "1",
      val: 1,
      color: "#0ea5e9",
      position: [0, 0, 0],
      scale: [2, 2, 2],
      rotation: [0, 0, 0],
    },
    {
      id: "2",
      val: 1,
      color: "#0ea5e9",
      position: [0, 0, 0],
      scale: [2, 2, 2],
      rotation: [0, 0, 0],
    },
    {
      id: "3",
      val: 1,
      color: "#10b981",
      position: [0, 0, 0],
      scale: [2, 2, 2],
      rotation: [0, 0, 0],
    },
    {
      id: "4",
      val: 1,
      color: "#0ea5e9",
      position: [0, 0, 0],
      scale: [2, 2, 2],
      rotation: [0, 0, 0],
    },
  ],
  edges: [
    {
      id: "1",
      source: "1",
      target: "0",
      color: "white",
    },
    {
      id: "2",
      source: "2",
      target: "0",
      color: "white",
    },
    {
      id: "3",
      source: "3",
      target: "0",
      color: "white",
    },
    {
      id: "4",
      source: "4",
      target: "2",
      color: "white",
    },
  ],
};
